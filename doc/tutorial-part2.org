* Introduction
In this second tutorial will introduce the permissions part of
Dispersy. To do this we will build an overlay that allows people to
join and interact with other people by reading and writing text
messages.  Essentially, we will build a small chat room.  Permissions
will be used to only allow /voiced/ people to create new text
messages, similar to a moderated IRC (Internet Relay Chat) channel.

The basic functionality of our chat room is the same as our [[tutorial-part1.org][previous
tutorial]] in that they both create an overlay where messages are
disseminated between peers.  This tutorial will focus on the new
permission concept.

The code samples are written in such a way, that when placed
sequentially in a python file, they result in a working chat room.
The code samples can be automatically extracted using [[filter_code.py]]
by running: =cat tutorial-part2.org | python filter_code.py python >
tutorial-part2.py=

* Moderated chat community
#+BEGIN_SRC python
import argparse
import signal
import struct

from dispersy.authentication import MemberAuthentication
from dispersy.callback import Callback
from dispersy.community import Community
from dispersy.conversion import DefaultConversion, BinaryConversion
from dispersy.destination import CommunityDestination
from dispersy.dispersy import Dispersy
from dispersy.distribution import FullSyncDistribution
from dispersy.endpoint import StandaloneEndpoint
from dispersy.message import Message
from dispersy.payload import Payload
from dispersy.resolution import PublicResolution

class ChatCommunity(Community):
    def __init__(self, dispersy, master_member, nickname):
        super(ChatCommunity, self).__init__(dispersy, master_member)
        self._nickname = nickname

    def initiate_conversions(self):
        return [DefaultConversion(self), ChatConversion(self)]
#+END_SRC

The [[tutorial-part1.org][previous tutorial]] skipped over the Dispersy master member to keep
the example concise.  However, we will now explain this concept as it
is the cornerstone of the permission system.

Let us start by saying that a Dispersy member is a wrapper around an
elliptic curve public/private key pair.  In this the master member is
no different, however, where most members represent an end user, the
master member represents an overlay.

The master member is used for two things:
- Peer discovery. :: Every Dispersy message contains a community
     identifier, which typically is the sha1 digest of the master
     member's public key.  Finding peers in an overlay, is as simple
     as sending an introduction request message to a (bootstrap) peer
     already in this overlay.

- Permission tree. :: Every Dispersy message comes with four
     permissions: permit, authorise, revoke, and undo (we will not
     cover undo in this tutorial).  

     Permit allows a user to create a message while authorise (and
     revoke) allows a user to give (and take away) permissions to (and
     from) other users for a message.

     Each of these permissions can be given to and taken from users on
     a message by message basis.  However, the master member is the
     exception: she has all permissions and they can not be taken away
     from her.  Effectively the master member is the root of the
     Dispersy permission tree.



** Message definitions
#+BEGIN_SRC python
    def initiate_meta_messages(self):
        return [Message(self,
                        u"text",
                        MemberAuthentication(encoding="bin"),
                        LinearResolution(),
                        FullSyncDistribution(enable_sequence_number=False, synchronization_direction=u"ASC", priority=128),
                        CommunityDestination(node_count=10),
                        TextPayload(),
                        self.check_text,
                        self.on_text),
                Message(self,
                        u"beg-permission",
                        MemberAuthentication(encoding="bin"),
                        PublicResolution(),
                        DirectDistribution(),
                        CommunityDestination(node_count=20),
                        BegPermissionPayload(),
                        self.check_beg_permission,
                        self.on_beg_permission)]
#+END_SRC

Given the simple nature of this tutorial most of the code consists of
the design of the text message and its handling.
=initiate_meta_messages= returns a list of Message instances.  In our
case, just a single message called "text".  Each message is given
policies that decide how this message will behave:

- =MemberAuthentication= ensures that every text message is signed
  using the cryptographic key of the author.  Setting the encoding to
  binary adds the author's public key into every message.  See
  [[../authentication.py][authentication.py]] for more options.

- =PublicResolution= ensures that everyone is allowed to create this a
  text message.  See [[../resolution.py][resolution.py]] for more options.

- =FullSyncDistribution= ensures that every text message is gossiped
  to every person who joins the chat room.  Note that multiple chat
  rooms can exist at the same time, each chat room has its own overlay
  and messages are only gossiped between people who are in the same
  overlay.

  When enabled, =enable_sequence_number= will include a sequence
  number in a message.  The first message created by someone will have
  number one.  Every subsequent text message, created by that same
  person, will have its sequence number incremented by one.  Dispersy
  will process all messages in sequence order, ensuring that no
  messages are missed.  Note that every message for every person in
  each overlay has its own sequence.

  The FullSyncDistribution policy uses bloom filters to efficiently
  find messages that are missing (i.e. pull mechanism), resulting in
  low bandwidth overhead.  =synchronization_direction= and =priority=
  influences the way that the synchronisation is performed.  See
  [[../distribution.py][distribution.py]] for more options.

- =CommunityDestination= ensures that the message will be distributed
  to everyone in the community.  =node_count= determines the number of
  people that will receive the message when it is created (i.e. push).
  See [[../destination.py][destination.py]] for more options.

- =TextPayload= describes the community specific payload.  In our chat
  room this will contain the author's nickname and the text.  The [[*
   Payload][payload section]] will explain how payload is defined.

- And finally, =check_text= and =on_text= are called when text
  messages are received.  The [[* Text message handling][message handling]] section explains how a
  text message is made and processed.

** Message handling
#+BEGIN_SRC python
    def create_text(self, text):
        meta = self.get_meta_message(u"text")
        allowed, proof = self.timeline.allowed(meta)
        if allowed:
            message = meta.impl(authentication=(self.my_member,),
                                distribution=(self.claim_global_time(),),
                                payload=(self._nickname, text))
            self.dispersy.store_update_forward([message], True, True, True)
        else:
            print "Cannot send to overlay (permission denied)"

    def check_text(self, messages):
        for message in messages:
            allowed, proofs = self.timeline.check(message)
            if allowed:
                yield message
            else:
                yield DelayMessageByProof(message)

    def on_text(self, messages):
        for message in messages:
            print "@%-3d uid%-3d %10s says: %s" %\
                (message.distribution.global_time,
                 message.authentication.member.database_id,
                 message.payload.nickname,
                 message.payload.text)
#+END_SRC

#+BEGIN_SRC python
    def create_beg_permission(self, voice, operator):
        meta = self.get_meta_message(u"beg-permission")
        message = meta.impl(authentication=(self.my_member,),
                            distribution=(self.claim_global_time(),),
                            payload=(voice, operator))
        self.dispersy.store_update_forward([message], False, False, True)

    def check_beg_permission(self, messages):
        meta = self.get_meta_message(u"text")
        allowed = (self.timeline.allowed(meta, permission=u"authorize") and
                   self.timeline.allowed(meta, permission=u"revoke"))

        for message in messages:
            if allowed:
                yield message
            else:
                yield DropMessage("Unable to grant or revoke permissions")

    def on_beg_permission(self, messages):
        meta = self.get_meta_message(u"text")
        for message in messages:
            print "on_beg_permission", message.payload.voice, message.payload.operator
            if message.payload.voice > 0:
                self.create_dispersy_authorize([(message.authentication.member, meta, u"permit")])

            elif message.payload.voice < 0:
                self.create_dispersy_revoke([(message.authentication.member, meta, u"permit")])

            if message.payload.operator > 0:
                self.create_dispersy_authorize([(message.authentication.member, meta, u"authorize"),
                                                (message.authentication.member, meta, u"revoke")])
            elif message.payload.operator < 0:
                self.create_dispersy_revoke([(message.authentication.member, meta, u"authorize"),
                                             (message.authentication.member, meta, u"revoke")])
#+END_SRC

Three things must be defined for each Dispersy message: creation,
verification, and handling.

The =create_text= method first retrieves the Message instance that
describes the text message.  This is the instance that we returned in
the [[* Message definitions][previous section]].  To create our actual text message we need to
/implement/ this meta message we create an actual text message by
providing it with the author, the current time, and the payload.

- The author is =self.my_member=.  This is the Member instance
  containing the cryptographic key that we use to identify ourselves.

- The current time is incremented and returned by
  =self.claim_global_time()=.  The global time of an overlay is
  implemented as a Lamport clock (i.e. a counter that is progressively
  incremented as new messages are created and received).

- Finally, the payload for our text message is the =self._nickname=
  and =text=.

When one or more new[fn::Dispersy ensures that no duplicate messages
are ever passed to either check_text or on_text] text messages are
received, they are first passed to =check_text=.  When a message is
invalid it can be (1) dropped by yielding a =DropMessage= instance, or
(2) delayed by yielding a =DelayMessage= instance when it depends on
something not yet available, or (3) accepted by yielding the message
itself.  In our chat room all text messages are accepted.

All valid messages that are ready to be processed are passed to the
=on_text= method.  In our chat room all messages are echoed to the
console.  For this tutorial we do not take into account that messages
are not received in the order that they were created.

** Keeping track of permission changes
#+BEGIN_SRC python
    def dispersy_store(self, messages):
        descriptions = dict()
        descriptions[(u"dispersy-authorize", u"text", u"permit")] = u"#@%-3d uid%-3d granted voice right to uid%-3d (can now create text messages)"
        descriptions[(u"dispersy-authorize", u"text", u"authorize")] = u"#@%-3d uid%-3d granted operator rights to uid%-3d (can now grant and revoke voice and operator rights)"
        descriptions[(u"dispersy-revoke", u"text", u"permit")] = u"#@%-3d uid%-3d revoked voice right from uid%-3d (can no longer create text messages)"
        descriptions[(u"dispersy-revoke", u"text", u"authorize")] = u"#@%-3d uid%-3d revoked operator rights from uid%-3d (can no longer grant and revoke voice and operator rights)"

        for message in messages:
            if message.name in (u"dispersy-authorize", u"dispersy-revoke"):
                for member, meta, permission in message.payload.permission_triplets:
                    description = descriptions.get((message.name, meta.name, permission))
                    if description:
                        print description %\
                            (message.distribution.global_time,
                             message.authentication.member.database_id,
                             member.database_id)
#+END_SRC

** Payload
#+BEGIN_SRC python
class TextPayload(Payload):
    class Implementation(Payload.Implementation):
        def __init__(self, meta, nickname, text):
            super(TextPayload.Implementation, self).__init__(meta)
            self.nickname = nickname
            self.text = text

class BegPermissionPayload(Payload):
    class Implementation(Payload.Implementation):
        def __init__(self, meta, voice, operator):
            super(BegPermissionPayload.Implementation, self).__init__(meta)
            self.voice = voice
            self.operator = operator
#+END_SRC

The TextPayload class is part of the (meta) Message implementation,
and hence it contains the chat room specific payload settings that we
want all text messages to follow.  In this case there are no such
settings.

The TextPayload.Implementation class describes what an actual text
message can contain, i.e. one message may contain a nickname and a
text.

When a message is received, the =nickname= and =text= properties are
available at =message.payload.nickname= and =message.payload.text=,
respectively.

** Conversion
#+BEGIN_SRC python
class ChatConversion(BinaryConversion):
    def __init__(self, community):
        super(ChatConversion, self).__init__(community, "\x01")
        self.define_meta_message(chr(1), community.get_meta_message(u"text"), self._encode_text, self._decode_text)
        self.define_meta_message(chr(2), community.get_meta_message(u"beg-permission"), self._encode_beg_permission, self._decode_beg_permission)

    def _encode_text(self, message):
        nickname = message.payload.nickname.encode("UTF-8")
        text = message.payload.text.encode("UTF-8")
        return struct.pack("!LL", len(nickname), len(text)), nickname, text

    def _decode_text(self, placeholder, offset, data):
        if len(data) < offset + 8:
            raise DropPacket("Insufficient packet size")

        nickname_length, text_length = struct.unpack_from("!LL", data, offset)
        offset += 8

        try:
            nickname = data[offset:offset+nickname_length].decode("UTF-8")
            offset += nickname_length

            text = data[offset:offset+text_length].decode("UTF-8")
            offset += text_length
        except UnicodeError:
            raise DropPacket("Unable to decode UTF-8")

        return offset, placeholder.meta.payload.implement(nickname, text)

    def _encode_beg_permission(self, message):
        return struct.pack("!bb", message.payload.voice, message.payload.operator),

    def _decode_beg_permission(self, placeholder, offset, data):
        if len(data) < offset + 2:
            raise DropPacket("Insufficient packet size")

        voice, operator = struct.unpack_from("!bb", data, offset)
        offset += 2

        return offset, placeholder.meta.payload.implement(voice, operator)
#+END_SRC

The ChatConversion class handled the conversion between the
Message.Implementation instances used in the code and the binary
string representation on the wire.

TODO: explain ="\x01"= and =define_meta_message=

The =_encode_text= method must return a tuple containing one or more
strings.  For our text message, we add the length and values of both
=nickname= and =text=, after they have been encoded to UTF-8.

The =_decode_text= method must return the new offset and a
TextPayload.Implementation instance.  =placeholder= contains
everything that has been decoded so far, =data= contains the entire
message as a string, and =offset= is the index of the first character
in =data= where the payload starts.

* Putting it all together
#+BEGIN_SRC python
def create_chat_room(dispersy, nickname):
    my_member = dispersy.get_new_member()
    return ChatCommunity.create_community(dispersy, my_member, nickname)

def join_chat_room(dispersy, hash_, nickname):
    master = dispersy.get_temporary_member_from_id(hash_.decode("HEX"))
    my_member = dispersy.get_new_member()
    return ChatCommunity.join_community(dispersy, master, my_member, nickname)

def main():
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-c", "--create", action="store_true", help="create a new chat room overlay")
    group.add_argument("-j", "--join", metavar="HASH", action="store", help="join an existing chat room by providing an overlay identifier")
    parser.add_argument("-p", "--port", action="store", type=int, default=3849, help="the UDP port that Dispersy should bind")
    parser.add_argument("-n", "--nickname", action="store", required=True, help="our nickname during chat")
    args = parser.parse_args()

    callback = Callback()
    endpoint = StandaloneEndpoint(args.port)
    dispersy = Dispersy(callback, endpoint, u".", u":memory:")
    dispersy.start()
    print "Dispersy is listening on port %d" % dispersy.lan_address[1]

    try:
        if args.create:
            community = callback.call(create_chat_room, (dispersy, unicode(args.nickname)))
            print "created chat room %s" % community.master_member.mid.encode("HEX")
        if args.join:
            community = callback.call(join_chat_room, (dispersy, args.join, unicode(args.nickname)))
            print "joined chat room %s" % community.master_member.mid.encode("HEX")

        while True:
            text = raw_input().strip()
            if text.startswith("/"):
                if text == "/+v":
                    callback.call(community.create_beg_permission, (1, 0))
                elif text == "/+o":
                    callback.call(community.create_beg_permission, (1, 1))
                elif text in ("/-v", "/-o"):
                    callback.call(community.create_beg_permission, (-1, -1))
            elif text:
                callback.call(community.create_text, (unicode(text),))

    except KeyboardInterrupt:
        print "shutdown"

    finally:
        dispersy.stop()

if __name__ == "__main__":
    main()
#+END_SRC

Now that we have our basic chat room implemented, we must start
Dispersy and join a chat room.  To start Dispersy we need to give it a
thread to run on and a UDP socket to listen to, this is handled by
=Callback()= and =StandaloneEndpoint(args.port)= respectively.

We instruct dispersy to use the current working directory to store any
databases, and use a =:memory:= SQLite database.  The following
=dispersy.start()= will start the callback thread, bind to the UDP
port, and create the database.

Based on what the user choose, either a new chat room is created or an
existing one is joined.  Note that either of these actions must take
place on the callback thread that is assigned to Dispersy, hence the
=callback.call(...)= will wait until Dispersy has finished the task
before returning the result.

The code ends up waiting for user input that, when provided, will be
made into a text message, stored to disk, and pushed to, at most ten,
other people who are online.  Joining an existing chat room will
immediately result in previous messages being synchronised between the
users.
